generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               Int               @id @default(autoincrement())
  email            String            @unique
  password         String?
  isActive         Boolean           @default(true)
  isVerified       Boolean           @default(false)
  roleId           Int
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  role             Role              @relation(fields: [roleId], references: [id])
  userDetail       UserDetail?       @relation("UserToUserDetail")
  userVerification UserVerification? @relation("UserToUserVerification")

  workersAssignToOrder workersAssignToOrder[]
  workOrder            workOrder[]

  checkIn checkIn[]

  checkOut checkOut[]
}

model UserDetail {
  id                  Int       @id @default(autoincrement())
  userId              Int       @unique
  names               String?
  lastNames           String?
  phone               String?
  address             String?
  birthDate           DateTime?
  documentTypeId      Int?
  documentNumber      String?   @unique
  profilePictureUrl   String?
  attachedDocumentUrl String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  currentCityId       Int?
  applicationCvUrl    String?
  socialSecurityUrl   String?

  documentType DocumentType? @relation(fields: [documentTypeId], references: [id])
  user         User          @relation("UserToUserDetail", fields: [userId], references: [id], onDelete: Cascade)

  userCostPerAssignment userCostPerAssignment[]
}

model userCostPerAssignment {
  id           Int        @id @default(autoincrement())
  userDetailId Int
  userDetail   UserDetail @relation(fields: [userDetailId], references: [id], onDelete: Cascade)

  assignmentId Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])

  costPerHour Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model UserVerification {
  id                         Int       @id @default(autoincrement())
  userId                     Int       @unique
  verificationCode           String?
  verificationCodeExpiry     DateTime?
  tokenToResetPassword       String?
  tokenToResetPasswordExpiry DateTime?
  createdAt                  DateTime  @default(now())
  updatedAt                  DateTime  @updatedAt
  user                       User      @relation("UserToUserVerification", fields: [userId], references: [id], onDelete: Cascade)
}

model DocumentType {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  userDetails UserDetail[]
}

model Role {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users     User[]
}

model Assignment {
  id             Int      @id @default(autoincrement())
  title          String
  costPerHour    Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  assignmentType Int

  workOrder                      workOrder[]                      @relation("assigmentWorkOrder")
  assignmentQuantityForWorkOrder assignmentQuantityForWorkOrder[]

  userCostPerAssignment userCostPerAssignment[]

  workersAssignToOrder workersAssignToOrder[]
}

model ClientCompany {
  id                           Int       @id @default(autoincrement())
  companyName                  String
  employerIdentificationNumber String
  employerEmail                String    @unique
  employerPhone                String
  representativeName           String
  IdUserRegistering            Int
  clientCityId                 Int
  clientAddress                String
  createdAt                    DateTime  @default(now())
  updatedAt                    DateTime? @updatedAt

  ContractClient ContractClient[]

  workOrder workOrder[]
}

model ContractClient {
  id                      Int              @id @default(autoincrement())
  clientId                Int
  client                  ClientCompany    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  contractCityId          Int
  contractAddress         String
  attachedContractUrl     String?
  contractCodePo          String
  totalContractValue      Int
  contractStatus          WorkOrderStatus? @default(PENDING)
  administrativeDiscounts Int
  DateStartWork           DateTime         @default(now())
  IdUserRegistering       Int
  createdAt               DateTime         @default(now())
  updatedAt               DateTime?        @updatedAt

  workOrder workOrder[]
}

enum WorkOrderStatus {
  PENDING // 1
  PARTIALLY_RUNNING // 2
  RUNNING // 3
  PARTIALLY_CLOSED // 4
  CLOSED // 5
  CANCELED // 6
  INACTIVE // 7
}

model workOrder {
  id Int @id @default(autoincrement())

  assigmentsClientReq  Assignment[]                     @relation("assigmentWorkOrder")
  assignmentQuantities assignmentQuantityForWorkOrder[]

  workOrderStartDate DateTime? @default(now())
  workOrderEndDate   DateTime? @default(now())
  orderWorkHourStart String?
  workOrderCodePo    String?

  supervisorUserId Int?
  supervisorUser   User? @relation(fields: [supervisorUserId], references: [id], onDelete: Restrict)

  workOrderStatus   WorkOrderStatus @default(PENDING)
  userEmailRegistry String
  createdAt         DateTime        @default(now())
  updatedAt         DateTime?       @updatedAt
  ContractClient    ContractClient? @relation(fields: [contractClientId], references: [id], onDelete: Restrict)
  contractClientId  Int?

  clientId      Int?
  clientCompany ClientCompany? @relation(fields: [clientId], references: [id], onDelete: Restrict)

  orderAssignToCollab orderAssignToCollabs[]

  checkIn checkIn[]

  checkOut checkOut[]
}

model assignmentQuantityForWorkOrder {
  id          Int       @id @default(autoincrement())
  workOrderId Int
  workOrder   workOrder @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  assignmentId Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])

  quantityWorkers Int
  createdAt       DateTime  @default(now())
  updatedAt       DateTime? @updatedAt
}

model orderAssignToCollabs {
  id          Int       @id @default(autoincrement())
  workOrderId Int
  workOrder   workOrder @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  orderWorkDateStart DateTime? @default(now())
  orderWorkDateEnd   DateTime? @default(now())

  orderWorkHourStart String?
  orderLocationWork  String
  orderObservations  String

  worksAssigned workersAssignToOrder[]

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model workersAssignToOrder {
  id Int @id @default(autoincrement())

  orderAssignToCollabId Int
  orderAssignToCollab   orderAssignToCollabs @relation(fields: [orderAssignToCollabId], references: [id], onDelete: Cascade)

  collaboratorId Int
  collaborator   User @relation(fields: [collaboratorId], references: [id], onDelete: Cascade)

  assignmentId Int?
  assignment   Assignment? @relation(fields: [assignmentId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model checkIn {
  id Int @id @default(autoincrement())

  orderId Int
  order   workOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  userCollabId Int
  userCollab   User @relation(fields: [userCollabId], references: [id], onDelete: Cascade)

  startTime     String
  initialStatus String?

  attachEvidenceOneUrl String?
  attachEvidenceTwoUrl String?

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model checkOut {
  id Int @id @default(autoincrement())

  orderId Int
  order   workOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  userCollabId Int
  userCollab   User @relation(fields: [userCollabId], references: [id], onDelete: Cascade)

  finalTime     String
  initialStatus String?

  attachEvidenceOneUrl String?
  attachEvidenceTwoUrl String?

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

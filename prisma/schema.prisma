generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               Int               @id @default(autoincrement())
  email            String            @unique
  password         String?
  isActive         Boolean           @default(true)
  isVerified       Boolean           @default(false)
  roleId           Int
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  role             Role              @relation(fields: [roleId], references: [id])
  userDetail       UserDetail?       @relation("UserToUserDetail")
  userVerification UserVerification? @relation("UserToUserVerification")

  workersAssignToOrder workersAssignToOrder[]
  workOrder            workOrder[]

  checkIn checkIn[]

  checkOut checkOut[]

  orderAcceptByCollab orderAcceptByCollab[]
  Invoice             Invoice[]

  breakPeriods breakPeriod[]

  collabObservations collabObservations[]
}

model UserDetail {
  id                  Int       @id @default(autoincrement())
  userId              Int       @unique
  names               String?
  lastNames           String?
  phone               String?
  address             String?
  birthDate           DateTime?
  documentTypeId      Int?
  documentNumber      String?   @unique
  profilePictureUrl   String?
  attachedDocumentUrl String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  currentCityId       Int?
  applicationCvUrl    String?
  socialSecurityUrl   String?

  documentType DocumentType? @relation(fields: [documentTypeId], references: [id])
  user         User          @relation("UserToUserDetail", fields: [userId], references: [id], onDelete: Cascade)

  userCostPerAssignment userCostPerAssignment[]
}

model userCostPerAssignment {
  id           Int        @id @default(autoincrement())
  userDetailId Int
  userDetail   UserDetail @relation(fields: [userDetailId], references: [id], onDelete: Cascade)

  assignmentId Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])

  costPerHour Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model UserVerification {
  id                         Int       @id @default(autoincrement())
  userId                     Int       @unique
  verificationCode           String?
  verificationCodeExpiry     DateTime?
  tokenToResetPassword       String?
  tokenToResetPasswordExpiry DateTime?
  createdAt                  DateTime  @default(now())
  updatedAt                  DateTime  @updatedAt
  user                       User      @relation("UserToUserVerification", fields: [userId], references: [id], onDelete: Cascade)
}

model DocumentType {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  userDetails UserDetail[]
}

model Role {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users     User[]
}

model Assignment {
  id             Int      @id @default(autoincrement())
  title          String
  costPerHour    Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  assignmentType Int

  workOrder                      workOrder[]                      @relation("assigmentWorkOrder")
  assignmentQuantityForWorkOrder assignmentQuantityForWorkOrder[]

  userCostPerAssignment userCostPerAssignment[]

  workersAssignToOrder workersAssignToOrder[]

  ClientPricePerAssignment ClientPricePerAssignment[]

  invoiceAssignments InvoiceAssignment[]
}

model ClientCompany {
  id                           Int       @id @default(autoincrement())
  companyName                  String
  employerIdentificationNumber String
  employerEmail                String    @unique
  employerPhone                String
  representativeName           String
  IdUserRegistering            Int
  clientCityId                 Int
  clientAddress                String
  createdAt                    DateTime  @default(now())
  updatedAt                    DateTime? @updatedAt

  ContractClient ContractClient[]

  workOrder workOrder[]

  ClientPricePerAssignment ClientPricePerAssignment[]

  Invoice Invoice[]

  collabObservations collabObservations[]
}

model ClientPricePerAssignment {
  id       Int           @id @default(autoincrement())
  clientId Int
  client   ClientCompany @relation(fields: [clientId], references: [id], onDelete: Cascade)

  assignmentId Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])

  pricePerHour Decimal  @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Invoice {
  id            Int      @id @default(autoincrement())
  invoiceNumber String?  @unique
  invoiceDate   DateTime @default(now())

  // Relaciones base
  clientId Int
  client   ClientCompany @relation(fields: [clientId], references: [id])

  userId Int
  user   User @relation(fields: [userId], references: [id])

  workOrderId Int
  workOrder   workOrder @relation(fields: [workOrderId], references: [id])

  // Snapshot de contexto
  clientName                   String
  employerIdentificationNumber String
  workOrderCodePo              String
  collaboratorName             String
  collaboratorDocumentNumber   String

  // Horas totales trabajadas
  totalHoursWorked Float

  // Totales base
  totalBaseCompany Float
  totalBaseCollab  Float

  // Totales finales con recargos
  totalWithSurchargesCompany Float
  totalWithSurchargesCollab  Float

  status     String   @default("ACTIVE")
  isDeleted  Boolean  @default(false)
  isDownload Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relaciones hijas
  invoiceAssignments InvoiceAssignment[]
}

model InvoiceAssignment {
  id Int @id @default(autoincrement())

  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  assignmentId Int?
  assignment   Assignment? @relation(fields: [assignmentId], references: [id])

  assignmentName String
  roleName       String?

  checkIn     DateTime
  checkOut    DateTime
  hoursWorked Float

  pricePerHourCompany      Float
  pricePerHourCollaborator Float
  totalAmountCompany       Float
  totalAmountCollaborator  Float

  // NUEVOS CAMPOS
  totalRegularCompany      Float @default(0)
  totalRegularCollaborator Float @default(0)

  // Recargos
  surchargeDetails InvoiceAssignmentSurcharge[]
}

model InvoiceAssignmentSurcharge {
  id Int @id @default(autoincrement())

  invoiceAssignmentId Int
  invoiceAssignment   InvoiceAssignment @relation(fields: [invoiceAssignmentId], references: [id])

  surchargeId Int
  surcharge   SalarySurcharge @relation(fields: [surchargeId], references: [id])

  // Horas en que aplica este recargo
  hoursApplied Float

  // Multiplicador o porcentaje aplicado (por si cambia despu√©s)
  appliedMultiplier Float
}

model SalarySurcharge {
  id         Int      @id @default(autoincrement())
  name       String
  percentage Float
  minHour    Int
  maxHour    Int?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  invoiceAssignmentSurcharges InvoiceAssignmentSurcharge[]
}

model ContractClient {
  id                      Int              @id @default(autoincrement())
  clientId                Int
  client                  ClientCompany    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  contractCityId          Int
  contractAddress         String
  attachedContractUrl     String?
  contractCodePo          String
  totalContractValue      Int
  contractStatus          WorkOrderStatus? @default(PENDING)
  administrativeDiscounts Int
  DateStartWork           DateTime         @default(now())
  IdUserRegistering       Int
  createdAt               DateTime         @default(now())
  updatedAt               DateTime?        @updatedAt

  workOrder workOrder[]
}

enum WorkOrderStatus {
  ACCEPT // 0
  PENDING // 1
  PARTIALLY_RUNNING // 2
  RUNNING // 3
  PARTIALLY_CLOSED // 4
  CLOSED // 5
  CANCELED // 6
  INACTIVE // 7
  DELETE // 8
}

model workOrder {
  id Int @id @default(autoincrement())

  assigmentsClientReq  Assignment[]                     @relation("assigmentWorkOrder")
  assignmentQuantities assignmentQuantityForWorkOrder[]

  workOrderStartDate DateTime? @default(now())
  workOrderEndDate   DateTime? @default(now())
  orderWorkHourStart String?
  workOrderCodePo    String?

  supervisorUserId Int?
  supervisorUser   User? @relation(fields: [supervisorUserId], references: [id], onDelete: Restrict)

  workOrderStatus   WorkOrderStatus? @default(PENDING)
  userEmailRegistry String
  createdAt         DateTime         @default(now())
  updatedAt         DateTime?        @updatedAt
  ContractClient    ContractClient?  @relation(fields: [contractClientId], references: [id], onDelete: Restrict)
  contractClientId  Int?

  clientId      Int?
  clientCompany ClientCompany? @relation(fields: [clientId], references: [id], onDelete: Restrict)

  orderAssignToCollab orderAssignToCollabs[]

  checkIn checkIn[]

  checkOut checkOut[]

  orderAcceptByCollab orderAcceptByCollab[]
  Invoice             Invoice[]

  collabObservations collabObservations[]
}

model assignmentQuantityForWorkOrder {
  id          Int       @id @default(autoincrement())
  workOrderId Int
  workOrder   workOrder @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  assignmentId Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])

  quantityWorkers Int
  createdAt       DateTime  @default(now())
  updatedAt       DateTime? @updatedAt
}

model orderAssignToCollabs {
  id          Int       @id @default(autoincrement())
  workOrderId Int
  workOrder   workOrder @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  orderWorkDateStart DateTime? @default(now())
  orderWorkDateEnd   DateTime? @default(now())

  orderWorkHourStart String?
  orderLocationWork  String
  orderObservations  String

  worksAssigned workersAssignToOrder[]

  workOrderStatus WorkOrderStatus? @default(PENDING)

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model workersAssignToOrder {
  id Int @id @default(autoincrement())

  orderAssignToCollabId Int
  orderAssignToCollab   orderAssignToCollabs @relation(fields: [orderAssignToCollabId], references: [id], onDelete: Cascade)

  collaboratorId Int
  collaborator   User @relation(fields: [collaboratorId], references: [id], onDelete: Cascade)

  assignmentId Int?
  assignment   Assignment? @relation(fields: [assignmentId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model orderAcceptByCollab {
  id Int @id @default(autoincrement())

  collaboratorId Int?
  collaborator   User? @relation(fields: [collaboratorId], references: [id])

  workOrderId Int?
  workOrder   workOrder? @relation(fields: [workOrderId], references: [id])

  acceptWorkOrder  Boolean? @default(false)
  confirmWorkOrder Boolean? @default(false)
  markedAtAsRead   Boolean? @default(false)

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model checkIn {
  id Int @id @default(autoincrement())

  orderId Int
  order   workOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  userCollabId Int
  userCollab   User @relation(fields: [userCollabId], references: [id], onDelete: Cascade)

  startTime     String
  initialStatus String?

  attachEvidenceOneUrl String?
  attachEvidenceTwoUrl String?

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  breakPeriods breakPeriod[]
}

model checkOut {
  id Int @id @default(autoincrement())

  orderId Int
  order   workOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  userCollabId Int
  userCollab   User @relation(fields: [userCollabId], references: [id], onDelete: Cascade)

  finalTime     String
  initialStatus String?

  attachEvidenceOneUrl String?
  attachEvidenceTwoUrl String?

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model breakPeriod {
  id Int @id @default(autoincrement())

  userCollabId Int?
  userCollab   User? @relation(fields: [userCollabId], references: [id], onDelete: Cascade)

  checkInId Int?
  checkIn   checkIn? @relation(fields: [checkInId], references: [id], onDelete: Cascade)

  breakStartTime String?
  breakEndTime   String?
  reason         String?

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model collabObservations {
  id Int @id @default(autoincrement())

  userCollabId Int?
  userCollab   User? @relation(fields: [userCollabId], references: [id])

  orderId   Int?
  workOrder workOrder? @relation(fields: [orderId], references: [id])

  clientId Int?
  client   ClientCompany? @relation(fields: [clientId], references: [id])

  observation String?
  rating      Decimal? @default(0)

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}
